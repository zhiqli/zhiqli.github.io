<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Test on 广阔天地大有作为</title>
    <link>https://zhiqli.github.io/tags/test/</link>
    <description>Recent content in Test on 广阔天地大有作为</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>© Copyright zhiqli</copyright>
    <lastBuildDate>Sat, 18 Mar 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://zhiqli.github.io/tags/test/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unit Test Best Practices </title>
      <link>https://zhiqli.github.io/2023/03/unit-test-best-practices/</link>
      <pubDate>Sat, 18 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://zhiqli.github.io/2023/03/unit-test-best-practices/</guid>
      <description>前言 在传统的观念中，认为开发工程师的主要职责是编写代码，首先因为自测容易产生思维盲区，其次在紧迫的业务需求下，开发工程师可能会把测试工作放在次要位置。&#xA;实际上，开发工程师的职责应该跟随整个开发周期，包括开发、测试、持续集成和交付，而不仅仅是编写代码并简单地跑通流程进行提测。当然，专业领域需要专业人员，测试工程师拥有比开发工程师更专业的能力和手段来提高软件质量，但是开发工程师也具备独特的优势。&#xA;开发工程师通过测试能够快速反馈代码的正确性，这不仅能确保代码一直走在正确的道路上，也是遵循测试驱动开发（TDD）的一种实践。 通过编写测试，开发人员可以成为自己代码的第一个客户，并且能够及时发现代码中可能存在的接口设计不合理之处，从而进行重构，避免在最后交付测试之后再进行大规模的修改。&#xA;关于测试 本书主要讲如何在企业级应用当中单元测试的实践经验。首先企业级应用的特点:&#xA;复杂的业务逻辑 很长的生命周期 中等规模的数据 性能要求不高 如下图所示，一个没有测试的项目可能在初期增长迅速，但到了后期却很难再有进展，甚至无法增长。而在有测试的情况下，测试又分为好的测试和坏的测试两种情况。坏的测试最终会导致与没有测试一样的困境，这种现象称为“软件熵”，即系统的无序程度会随着代码修改的次数而增加。如果不对代码进行清理和重构，最终代码将变得不可靠。&#xA;因此，单元测试的目标是确保软件的可持续发展，即在长期的开发过程中，仍然可以持续演进。&#xA;如何衡量测试的质量 测试覆盖率是一个衡量测试质量的指标。指被执行的代码行数与代码总函数数之比。还有一个更准确的指标是分支覆盖率，即被测试的分支数与总分支数之比。&#xA;然而，并不是说测试覆盖率越高就越好。高覆盖率的代码并不一定就是无可挑剔、没有bug的代码，低覆盖率的代码也不一定质量很差。测试覆盖率是一个好的逆向指标，它可以帮助我们判断测试用例是否充分，但并不是一个好的正向指标。如果我们只是一味地追求高覆盖率，可能会产生反效果。因此，测试覆盖率只是测试质量的一个衡量指标而不是目标，需要结合其他测试指标和质量评估方法来综合评价测试的好坏。&#xA;测试也是有成本的，包括：&#xA;需要重构测试时的成本 每次修改代码时运行测试所需的时间成本 处理由测试引起的误报所需的成本 在试图了解代码的行为时需要阅读测试代码所需的时间成本。 因此，我们需要权衡测试的价值和成本，确保测试数量和质量达到一个合理的平衡点。&#xA;什么是一个成功的测试 一个成功的测试具有3个特征&#xA;它跟随整个开发周期 它只专注于最重要的那部分代码（一般是业务逻辑代码即领域模型），基础架构和外部库是不需要运行单测的。 用最小的维护成本来提供最大价值，所以需要程序员识别有价值的测试，并编写有价值的测试 什么是单元测试 单元测试一般指一个自动化的测试，核心条件包括&#xA;验证一小块代码 快速执行 以隔离的方式运行 关于隔离的不同理解形成了两种风格，伦敦派和经典派。&#xA;伦敦派认为单元测试通常是针对代码中的一个单元（通常是一个类）进行测试。在进行测试时，应该专注于被测试的代码，并使用测试替身来隔离与其交互的依赖项。这样做的好处包括提供更细粒度的测试、定位问题更容易以及测试速度更快。&#xA;然而，这种方法的问题在于，它并不合理地将单元定义为代码中的单个功能。相反，一个测试用例应当是对系统功能的内聚且有意义的描述。通过以类的角度进行拆分，测试用例可能会变得支离破碎，难以理解。此外，如果由于类之间的复杂关系而难以测试，则这是设计问题，使用测试替身只是隐藏问题而非解决问题。最后，对于单元测试来说，定位问题总是相对简单的，因此这种方法和关注单个功能的方法之间的差距很小。&#xA;经典派则认为一个单元应该是一个单一功能。相比之下，经典学派并不认为单元代码需要被隔离测试，而是认为单元测试本身应该在相互隔离的情况下执行，以确保各个测试在运行中互不影响。 在进行单元测试时，只有在共享依赖的情况下才需要使用mock。本书的观点偏向于经典学派。&#xA;关于依赖分类，可以分为以下几种&#xA;共享的依赖是指会对测试之间的结果产生影响的依赖，比如静态变量和数据库。在这里，共享指的是单元测试之间的共享，而不是单元内部类之间的共享。 私有的依赖是不共享的依赖。 进程外的依赖是指应用程序之外的依赖，比如数据库、文件系统和第三方程序。数据库既可以是共享依赖，也可以是进程外依赖。例如，如果每次使用docker重新启动数据库，那么它就不是共享的依赖。 下图展示两种风格是怎么处理依赖的&#xA;在TDD和过度规范的问题上，伦敦派和经典派之间也有所不同。伦敦派采用自上而下的TDD方式，通过mock掉交互方，可以先编写高层次的测试来为整个功能设定目标，然后逐步细化具体实现。相比之下，经典派则更倾向于使用自下而上的TDD流程，先建立核心的领域模型，再逐步添加周边功能。&#xA;两个流派最重要的区别在于过度规范的问题，即测试用例与系统实现细节的耦合。伦敦派更容易产生这种耦合，这也是本书对伦敦派和滥用mock最反对的地方。&#xA;如何组织一个单元测试 一般提倡AAA测试范式，所谓AAA测试范式指的是&#xA;Arrange： 组织初始化一些参数和依赖。 Act： 执行被测试函数。 Assert：对输出结构断言，包括返回值、SUT的状态、交互方的状态以及预期交互行为 还有一个对应的Given-When-Then范式。在编写单元测试时，最好从Arrange开始，逐步完成测试。避免一个测试中多个Arrange、Act、Assert。&#xA;单元测试最好遵循单一职责原则，确保测试简单、快速、易于理解，以下是一些实践建议：&#xA;如果一个测试包含多个行为，请重构成多个单独的测试。 避免在测试中使用if语句，保证测试步骤简单、串行。 Arrange部分通常是最大的，但过大也会影响可读性，可以将比较复杂的对象初始化和数据构造抽取为函数。 Act部分通常只有一行代码，即被测试函数的调用。 Assert部分应该针对被测试函数的每个行为进行断言，因为单元测试是测试行为而不是代码，而一个函数可能有多个行为，所以Assert可能会有多个。 如果存在第三方资源（如数据库）的依赖，可以在集成测试中使用Teardown阶段释放资源，单元测试一般不需要考虑此类情况，因为单元测试不会有太多第三方依赖。 单元测试的四大支柱特性 这是本书中最核心的内容，一个好的单元测试应该具备以下四个特性，Protection against regressions（防止回归），Resistance to refactoring（抵御重构），Fast feedback（快速反馈），Maintainability（可维护性）。&#xA;快速反馈意味着只有测试足够快，才能够鼓励开发人员编写更多的测试，并且更经常地运行它们。 可维护性则包括测试代码的可理解性和测试代码运行的易用性 。 防止回归指的是当代码中出现bug的时候，能够被测试所发现。通常情况下，当修改代码后导致原有功能失效时，这些问题只有通过测试才能被发现。因此，测试应该覆盖尽可能多的代码，以确保代码的稳定性和质量。代码不是资产，而是负债，因此代码越多，越容易出现问题。 抵御重构，当你这是重构了一些代码（主要指非功能性修改，比如rename，调整代码结构等），测试却失败了。这种情形叫false positive也就是误报，即测试失败，但实际上被测试代码的功能却一切正常。 而false positive的干扰会带来两个问题： 如果测试失败的原因不充分，就会削弱你对代码中问题做出反应的能力和意愿。随着时间的推移，你可能会忽略本来应该出现的错误。 如果false positive太多，你会对测试失去信任，这种信任会导致更少的重构。 那么是什么导致了false positive呢？</description>
    </item>
  </channel>
</rss>
