<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Envoy on 广阔天地大有作为</title>
    <link>https://zhiqli.github.io/tags/envoy/</link>
    <description>Recent content in Envoy on 广阔天地大有作为</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <copyright>© Copyright zhiqli</copyright>
    <lastBuildDate>Tue, 10 Sep 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://zhiqli.github.io/tags/envoy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>envoy 代理http1.1</title>
      <link>https://zhiqli.github.io/2019/09/envoy-%E4%BB%A3%E7%90%86http1.1/</link>
      <pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate>
      <guid>https://zhiqli.github.io/2019/09/envoy-%E4%BB%A3%E7%90%86http1.1/</guid>
      <description>&lt;p&gt;最近处理了一个envoy代理http1.1的问题，先简单介绍一下背景&lt;/p&gt;&#xA;&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;p&gt;我们有一个长连接通道的项目，原来是通过http2.0连接。后来因为要做扫码登录的业务，所以使用 socket.io&#xA;支持了http1.1的连接，这是同事当时支持http1.1以后的&lt;a href=&#34;https://segmentfault.com/a/1190000017751461&#34;&gt;博客&lt;/a&gt;。&#xA;代理当初用的envoy是1.6 v1 API ，现在由于其他问题想升级envoy到新版本，而新版本已经不支持v1 API，在升级的过程中遇到一些问题，也花了不少时间，搞定以后以此文作为笔记。&lt;/p&gt;&#xA;&lt;h3 id=&#34;服务部署结构&#34;&gt;服务部署结构&lt;/h3&gt;&#xA;&lt;p&gt;&#xA;  &lt;img src=&#34;https://user-images.githubusercontent.com/3350002/64596783-2305ce80-d3e7-11e9-86cf-9b9877f6642d.png&#34; alt=&#34;7ABEC0B0-2C40-47BF-89B3-B85AA8F0481A&#34;&gt;&#xA;&#xA;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;front-envoy&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这是一个网关。需要处理客户端http1.1的请求，在envoy API v1的时候非常简单，只需要在Route中加上&lt;code&gt;use_websocket=true&lt;/code&gt;即可，&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.7.0/api-v1/route_config/route.html?highlight=use_websocket&#34;&gt;参考文档&lt;/a&gt;。&#xA;但是在API v2，这个配置修改了，&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/network/http_connection_manager/v2/http_connection_manager.proto.html?highlight=upgrade_configs&#34;&gt;参考文档&lt;/a&gt;，在&lt;code&gt;http_connection_mananger&lt;/code&gt;中加&lt;code&gt;upgrade_configs&lt;/code&gt;配置。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;envoy1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这实际上是k8s ingress，本来其实这个envoy就可以直接对外了，由于在阿里云slb的连接数有限制，所以才有在前面加了frontenvoy，有了frontenvoy连接会收敛，虽然front-envoy有一百多万连接，但到这里的连接数就很少了。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;envoy2&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;看得出来这是sidecar envoy。只需要加上sio的upstream cluster即可。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;&#xA;&lt;p&gt;背景已经交代清楚了，这里再说下问题。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;envoy升级以后，按照配置设置了&lt;code&gt;upgrade_configs&lt;/code&gt;，请求发现front-envoy一直报错，503 UR，即upstream reset。&#xA;再跟踪envoy1的trace日志，发现有一行日志&lt;code&gt;invalid frame: Invalid HTTP header field was received&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查了好久都没找到答案，上github提了一个issue，后来回复，由于envoy之间是http2连接，需要设置&lt;code&gt;allow_connect=true&lt;/code&gt;才行，参考&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/websocket.html?highlight=upgrade_configs#handling-http-2-hops&#34;&gt;文档描述&lt;/a&gt;。&#xA;由于之前文档没有描述&lt;code&gt;allow_connect&lt;/code&gt;，现在看到的是我提了issue才加上的描述。所以自己查了很久也没搞定。&#xA;&#xA;  &lt;img src=&#34;https://user-images.githubusercontent.com/3350002/64596850-44ff5100-d3e7-11e9-955d-e3336b5c50f8.png&#34; alt=&#34;85E35B00-1ED3-4007-A063-057E975B8A26&#34;&gt;&#xA;&#xA;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;设置上&lt;code&gt;allow_connect&lt;/code&gt;以后，frontenvoy的日志从503 UR变成503了。&#xA;查看envoy1的日志，503 UR 以及&lt;code&gt;invalid frame: Invalid HTTP header field was received&lt;/code&gt;。和刚才envoy1一样的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;而envoy2已经设置了&lt;code&gt;allow_connect&lt;/code&gt;啊。后来查明原来我是在&lt;code&gt;cluster&lt;/code&gt;里面的&lt;code&gt;http2_protocol_options&lt;/code&gt;中设置了&lt;code&gt;allow_connect=true&lt;/code&gt;，需要在&lt;code&gt;http_connection_mananger&lt;/code&gt;中的&lt;code&gt;http2_protocol_options&lt;/code&gt;中设置。&lt;/p&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;设置完成，envoy2又出现以下日志&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&#xA;&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1&#xA;&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[2019-09-10 07:14:56.094][000057][info][client] [source/common/http/codec_client.cc:118] [C3693] protocol error: The user callback function failed&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[2019-09-10T07:14:55.632Z] &amp;#34;GET /xlchannel.app2amlogic/sio/?EIO=3&amp;amp;transport=websocket HTTP/2&amp;#34; 503 UC 0 57 1 - &amp;#34;192.168.61.139,172.30.30.103,172.30.30.116&amp;#34; &amp;#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&amp;#34; &amp;#34;89018dc4-226f-4813-805d-7bb4d1332a60&amp;#34; &amp;#34;10.10.75.131&amp;#34; &amp;#34;127.0.0.1:8080&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;再检查一遍配置，发现我在upstream cluster中加了&lt;code&gt;http2_protocol_options{}&lt;/code&gt;这就指定协议为http2，v1配置可以用&lt;code&gt;&amp;quot;features&amp;quot;:&amp;quot;http2&amp;quot;,&lt;/code&gt;配置为http2，默认http。而在v2配置中，需要通过&lt;code&gt;http2_protocol_options{}&lt;/code&gt;指定协议为http2，&lt;code&gt;http_protocol_options{}&lt;/code&gt;或不填表示http。&lt;/p&gt;</description>
    </item>
    <item>
      <title>envoy ratelimit技术验证</title>
      <link>https://zhiqli.github.io/2019/08/envoy-ratelimit%E6%8A%80%E6%9C%AF%E9%AA%8C%E8%AF%81/</link>
      <pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate>
      <guid>https://zhiqli.github.io/2019/08/envoy-ratelimit%E6%8A%80%E6%9C%AF%E9%AA%8C%E8%AF%81/</guid>
      <description>&lt;p&gt;nginx大法好啊，nginx5分钟解决了一个envoy带来两周的伤害。&lt;/p&gt;&#xA;&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;&#xA;&lt;p&gt;具体情况是这样的，我这边有个服务大概结构是这样的。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  &lt;img src=&#34;https://user-images.githubusercontent.com/3350002/63155615-7df51180-c045-11e9-90d5-072d7433da5b.png&#34; alt=&#34;img&#34;&gt;&#xA;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;高峰时大概承接了150w的grpc长连接，以及小于1000的websocket长连接。&#xA;上个月底由于已发版的客户端有个bug，会在后台不停发websocket建立连接请求，导致在一个周日下午5点半线上服务频繁重启，还好k8s会自动拉起服务。在超市买菜做晚饭的我赶紧冲回去，这时候能咋办呢。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;扩容&lt;/strong&gt;，把pod数增加一倍，然而并没有卵用，还是秒挂。由于前端envoy有5个实例，跟领导报备，先做服务降级，把其中4个envoy关闭websocket，先保证这100来万grpc连接能正常啊。&#xA;挺过一晚上，周一去到公司，讨论了一上午，最后的方案是隔离，把最前面的envoy分离，websocket的域名只走单独的两个envoy。慢慢的服务平稳了一周。服务变成这样子&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  &lt;img src=&#34;https://user-images.githubusercontent.com/3350002/63155616-7e8da800-c045-11e9-86a4-0fad0e15fbcc.png&#34; alt=&#34;img&#34;&gt;&#xA;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;第二周，同样的周日下午5:30，k8s ingress 又出现大面积重启，还是老方法，扩容，周一ingress也隔离。于是服务又变成这样子&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  &lt;img src=&#34;https://user-images.githubusercontent.com/3350002/63155617-7e8da800-c045-11e9-8ab0-8a3ed4e9b251.png&#34; alt=&#34;img&#34;&gt;&#xA;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;同时调研envoy ratelimit，这又是一个悲伤的故事。由于我们用的还是envoy1.6或者1.7（别问为什么，问就是以前团队留下的坑），试了ratelimt发现，grpc和http都能有效限制remote_address的请求次数，就是websocket无效。又验证最新的envoy，发现没有问题。&lt;/p&gt;&#xA;&lt;p&gt;这时候升级envoy就完事了吧，领导觉得动作太大，因为从网关到服务，实际上有三个envoy（包括sidecar里面的envoy），都得升级，否则websocket请求全部是503 UR，还不保证服务里面的socket io相关代码不需要修改。&lt;/p&gt;&#xA;&lt;p&gt;最后祭出nginx大法。昨晚下班前5分钟在测试环境配置nginx，验证通过。&#xA;今天早上业务验证通过，上线，持续观察了几天，再也没有重启过，业务同学也再也没找过我了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;&#xA;&lt;p&gt;总结一下这次解决问题的过程&#xA;envoy提供ratelimit的api，可以接入一个全局的速率限制服务，lyft已经提供了一个&lt;a href=&#34;https://github.com/lyft/ratelimit&#34;&gt;ratelimt&lt;/a&gt;服务可以参考甚至直接用。关于限速配置，readme中有详细说明。&lt;/p&gt;&#xA;&lt;p&gt;关于envoy配置，官方文档中也有描述，不过各版本之间略有差异，需要针对各版本进行配置，最新版，网上有一个 &lt;a href=&#34;https://github.com/jbarratt/envoy_ratelimit_example&#34;&gt;envoy_ratelimit_example&lt;/a&gt;&#xA;可以参考，而低版本则可以通过官文文档进行配置。&lt;/p&gt;&#xA;&lt;p&gt;虽然这次折腾没有用上envoy ratelimit，不过也算是一次技术调研，在后面的服务中可能可以用上，特以此文作为笔记。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
